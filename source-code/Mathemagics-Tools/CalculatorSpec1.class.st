"
Spec1 version.

Class part: Although Smalltalk is so powerful, it was surprised nobody wrote calculator to handle simple mathematical expressions. Then I realised why..: It's very complicated.
This humble calculator is designed to do the work for the basics expressions using the simple parser and the expression tree.

Responsibility part: Allows entering a mathematical expression in infix format, and parse and represent the value. Also allows to copy that expression to the clipboard to paste inside your own code. Should have a button to evaluate the expression and generate the derivative for a variable.

Collaborators Part: The entered expression is parsed with the parser in the same package. The internal structure generated by the parser using MathExpression hierarchy tree.

Public API,  Key Messages, implementation points: The class is not designed for interacting with it, is a stand alone object. Multiple instances are allowed and are independent. Use the #example(s) methods to create the instance.

"
Class {
	#name : #CalculatorSpec1,
	#superclass : #ComposableModel,
	#instVars : [
		'errorArea',
		'historyArea',
		'inputArea',
		'toolbar',
		'editloopbug'
	],
	#category : #'Mathemagics-Tools-Apps'
}

{ #category : #specs }
CalculatorSpec1 class >> defaultSpec [
	<spec: #default>
	"Simple design, the history list, the current expression, and the buttons"
	^ SpecColumnLayout composed
		newRow: [ :t | t add: #toolbar ] height: self toolbarHeight;
		newRow: [ :t | t add: #inputArea ] height: 30;
		newRow: [ :t | t add: #historyArea ];
		newRow: [ :t | t add: #errorArea ] height: 30;
		yourself
]

{ #category : #'instance creation' }
CalculatorSpec1 class >> open [
	"Start a fresh calculator"
	^ (self new) openWithSpec; yourself.
]

{ #category : #'helper methods' }
CalculatorSpec1 >> alertMessage: aMessage [
	"Message and dialog"
	^ UIManager default alert: aMessage.
]

{ #category : #'helper methods' }
CalculatorSpec1 >> alertQuestion: aMessage [
	"Message and dialog"
	^ UIManager default questionWithoutCancel: aMessage.
]

{ #category : #'user interface' }
CalculatorSpec1 >> clickedClearHistory [
	"Ask and clear"
	(self alertQuestion: 'Clear the history?') ifFalse: [ ^ self ].
	"Go for it.. but I dont like the 'Guarding clause' warning"
	historyArea resetSelection.
	historyArea items: #().
]

{ #category : #'user interface' }
CalculatorSpec1 >> clickedCopyAsBlock [
	"Formats so can be pasted into your code"
	| compilerText expression |

	historyArea selectedItem ifNil: [ ^ self alertMessage: 'Select an expression to copy.' ].

	"in the editor, I just paste the text as it is"
	expression := self codeOutExpression: (historyArea selectedItem).

	"This one is simpller"
	compilerText := expression asBlock asString.

	"Done"
	Clipboard clipboardText: compilerText.
	self inform: 'Expression copied to clipboard: ' , Character cr asString , compilerText.
]

{ #category : #'user interface' }
CalculatorSpec1 >> clickedCopyAsParser [
	"Formats so can be pasted into your code"
	| compilerText expression |

	historyArea selectedItem ifNil: [ ^ self alertMessage: 'Select an expression to copy.' ].

	"in the editor, I just paste the text as it is"
	expression := self codeOutExpression: (historyArea selectedItem).

	"I build the parser text"
	compilerText := MathExpression name asString.
	compilerText := compilerText , Character space asString.
	compilerText := compilerText , (MathExpression class methodNamed: #from:) selector.
	compilerText := compilerText , Character space asString.
	compilerText := compilerText , $' asString , expression asString , $' asString.

	"Done"
	Clipboard clipboardText: compilerText.
	self inform: 'Expression copied to clipboard: ' , Character cr asString , compilerText.
]

{ #category : #'user interface' }
CalculatorSpec1 >> clickedDelete [
	"Remove the selected or the last one otherwise"
	| item newList |
	historyArea selectedItem ifNil: [ ^ self alertMessage: 'Select an expression to delete.' ].

	"Do the work"
	item := historyArea selectedItem.
	historyArea resetSelection.
	newList := historyArea getList select: [ :value | value ~~ item ].
	historyArea items: newList.
]

{ #category : #'user interface' }
CalculatorSpec1 >> clickedDerivative [
	"Write down the derivative of the expression"
	| item expression variables selectedVariable |
	historyArea selectedItem ifNil: [ ^ self alertMessage: 'Select an expression.' ].

	"for some reason the TextModel>>text: accepts automatically.. I avoid this.."
	item := historyArea selectedItem.

	"Notice previously this reinserted the text.."
	expression := (self codeOutExpression: item) copy.

	"Does it have variables.. otherwise makes no sense.."
	variables := expression variables.
	variables ifEmpty: [ ^ self alertMessage: 'There are no variables in the expression: "' , expression asString , '"'].

	"Go though them and once all... happy.. calculate"
	selectedVariable := UIManager default chooseDropList: 'Select the variable:' list: variables asArray.

	"Finally.."
	self solveDerivative: expression for: selectedVariable.
]

{ #category : #'user interface' }
CalculatorSpec1 >> clickedEdit [
	"Reedit the selection"
	historyArea selectedItem ifNil: [ ^ self alertMessage: 'Select an expression to edit.' ].

	"for some reason the TextModel>>text: accepts automatically.. I avoid this.."
	editloopbug := historyArea selectedItem.

	"Notice previously this reinserted the text.."
	inputArea text: (self codeOutExpression: editloopbug).

	"Select the text to enable input something else"
	inputArea selectAll.
	inputArea takeKeyboardFocus.

	"to be tidy"
	editloopbug := nil.
]

{ #category : #'user interface' }
CalculatorSpec1 >> clickedEvaluate [
	"Calculates the selection"
	| item expression variables |
	historyArea selectedItem ifNil: [ ^ self alertMessage: 'Select an expression to evaluate.' ].

	"for some reason the TextModel>>text: accepts automatically.. I avoid this.."
	item := historyArea selectedItem.

	"Notice previously this reinserted the text.."
	expression := (self codeOutExpression: item) copy.

	"Does it have variables.. otherwise makes no sense.."
	variables := expression variables.
	variables ifEmpty: [ ^ self alertMessage: 'There are no variables in the expression: "' , expression asString , '"'].

	"Go though them and once all... happy.. calculate"
	variables do: [ :eachVariable |
		| valueEntered |
		"Ask for each value"
		valueEntered := UIManager default textEntry: 'Enter a value for variable "' , eachVariable symbol asString , '"'.
		"CANCEL = nil = stop.."
		valueEntered ifNil: [ ^ self inform: 'Evaluation cancelled.' ].
		"If I cant recognise the extended number.. stop and warn.."
		(MathExpNumber numberValidation: valueEntered) ifFalse: [ ^ self alertMessage: 'Cannot process entry: ' , valueEntered asString ].
		"horoo.. I set the value in the variable"
		eachVariable value: (MathExpression safeguard: valueEntered).
	].

	"Looped to all (usually is one or two...)"
	self solveExpression: expression.

	"Clear out..."
	variables do: [ :eachVariable | eachVariable value: nil ].
]

{ #category : #'user interface' }
CalculatorSpec1 >> clickedInspect [
	"So the user can see the internal structure"
	| expression |
	historyArea selectedItem ifNil: [ ^ self alertMessage: 'Select an expression to inspect.' ].

	"Do the work"
	expression := self codeOutExpression: (historyArea selectedItem).
	expression inspect.
]

{ #category : #'user interface' }
CalculatorSpec1 >> clickedMoveDown [
	"Moves the selection"
	| item newList |
	historyArea selectedItem ifNil: [ ^ self alertMessage: 'Select an expression to move.' ].

	"Do the work"
	item := historyArea selectedItem.
	historyArea resetSelection.
	newList := historyArea getList select: [ :value | value ~~ item ].
	newList := ( newList , { item } ).
	historyArea items: newList.
	historyArea setSelectedItem: item.
]

{ #category : #'user interface' }
CalculatorSpec1 >> clickedMoveUp [
	"Moves the selection"
	| item newList |
	historyArea selectedItem ifNil: [ ^ self alertMessage: 'Select an expression to move.' ].

	"Do the work"
	item := historyArea selectedItem.
	historyArea resetSelection.
	newList := historyArea getList select: [ :value | value ~~ item ].
	newList := ( { item } , newList ).
	historyArea items: newList.
	historyArea setSelectedItem: item.
]

{ #category : #'user interaction' }
CalculatorSpec1 >> codeInSymbol: aSourceSymbol andExpression: anExpression [
	"I store an array for each.. is just simple.. and prefer to have more classes at thsi time.."
	^ aSourceSymbol -> anExpression
]

{ #category : #'user interaction' }
CalculatorSpec1 >> codeOutExpression: aLine [
	"Retrieve the wanted value"
	^ aLine value
]

{ #category : #'user interaction' }
CalculatorSpec1 >> codeOutIcon: aLine [
	"I know.. clever eh!!!"
	^ self iconNamed: aLine value class systemIconName.
]

{ #category : #'user interaction' }
CalculatorSpec1 >> codeOutText: aLine [
	"Retrieve the wanted value"
	| symbol expression text spaces |
	symbol := aLine key.
	expression := aLine value.

	"Here the expression will become readable"
	text := expression asString.

	"input just ends here"
	(symbol = #input) ifTrue: [ ^ text "exit now" ].

	"add spaces"
	spaces := '   '.

	".. solutions add the equals and the text "
	(symbol = #solution) ifTrue: [ text := spaces , '= ' , text ].

	".. solutions add the equals and the text "
	(symbol = #derivative) ifTrue: [ text := spaces , 'f'' = ' , text ].

	"sometimes.. I may get a Fraction like (1/2) so I present both solutions then"
	(expression isNumber) ifTrue: [
		"So annoying.. 3 asFraction says YES!? but not really... this is a workaround"
		| numbery |
		numbery := expression asNumber.
		(expression isNumericConstant not) | (numbery class = Fraction) ifTrue: [ text := text , ' = ' , (numbery asFloat asString) ].
	].

	"done"
	^ text.
]

{ #category : #'helper methods' }
CalculatorSpec1 >> errorArea [
	^ errorArea.
]

{ #category : #api }
CalculatorSpec1 >> extent [
	^ 500@350.
]

{ #category : #'helper methods' }
CalculatorSpec1 >> historyArea [
	^ historyArea.
]

{ #category : #initialization }
CalculatorSpec1 >> initializeErrorArea [
	"Where I show messages"
	errorArea := self newLabel.
	^ errorArea.
]

{ #category : #initialization }
CalculatorSpec1 >> initializeHelpSubmenu [
	"List what is available"
	| myList |
	myList := Dictionary new.
	MathExpression allSubclasses do: [ :each |
		(each class selectors includes: #mathSymbol) ifTrue: [
		| text key  |
			text := each mathSymbol asString.
			key := (each isSimpleOperator) ifTrue: [ 'A' , each precedence asString ] ifFalse: [ 'B' ].
			key := key , ')' , text asLowercase.
			text ifNotEmpty: [ myList add: key -> text ].
		].
	].
	"finally build the menus"
	^ MenuModel new addGroup: [ :group |
			myList keysSortedSafely do: [ :key |
				group addItem: [ :item | item name: (myList at: key) asString "action: [
						The edit doesnt work !
						reediting := group.
						self inputArea text: self inputArea text , ' ' , (myList at: key).
						reediting := nil.
				]" ].
			].
		].
]

{ #category : #initialization }
CalculatorSpec1 >> initializeHistoryArea [
	"Build are displaying previous entries.."

	historyArea := self newIconList.
	historyArea displayBlock: [ :item | self codeOutText: item ].
	historyArea icons: [ :item | self codeOutIcon: item ].
	"historyArea backgroundColorBlock: [ :item | depends.. ]... unfortunately this doesnt work with IconList"

	"Ready"
	^ historyArea.
]

{ #category : #initialization }
CalculatorSpec1 >> initializeInputArea [
	"Current is the one you see evaluating"
	inputArea := TextInputFieldModel new.
	inputArea whenTextChanged: [ :input | self processInputExpression: input ].
	inputArea ghostText: 'Write here a mathematical expression and press [ENTER]'.
	^ inputArea.
]

{ #category : #initialization }
CalculatorSpec1 >> initializeToolbar [
	"Do make it simpler"
	toolbar := MenuModel new
		addGroup: [ :group |
			self newButtonOn: group title: 'Edit' hint: 'Edit selected' icon: #edit action: [ self clickedEdit ].
			self newButtonOn: group title: 'Eval' hint: 'Evaluate variables' icon: #smallLoadProject action: [ self clickedEvaluate ].
			self newButtonOn: group title: 'f ''(x)' hint: 'Derivative' icon: #smallNew action: [ self clickedDerivative ].
		];
		addGroup: [ :group |
			self newButtonOn: group title: 'Help'
												hint: 'Show operators and functions' icon: #help
												action: nil
												submenu: self initializeHelpSubmenu.
		];
		addGroup: [ :group |
			self newButtonOn: group hint: 'Inspect selected' icon: #smallInspectIt action: [ self clickedInspect ].
			self newButtonOn: group hint: 'Copy as parser to clipboard' icon: #smallCopy action: [ self clickedCopyAsParser ].
			self newButtonOn: group hint: 'Copy as block to clipboard' icon: #collection action: [ self clickedCopyAsBlock ].
		];
		addGroup: [ :group |
			self newButtonOn: group hint: 'Move selected up' icon: #up action: [ self clickedMoveUp ].
			self newButtonOn: group hint: 'Move selected down' icon: #down action: [ self clickedMoveDown ].
			self newButtonOn: group hint: 'Delete selected' icon: #remove action: [ self clickedDelete ].
			self newButtonOn: group hint: 'Clear history' icon: #class action: [ self clickedClearHistory ].
		];
		addGroup: [ :group |
			self newButtonOn: group hint: 'New calculator' icon: self class systemIconName action: [ self class open ].
		].
	toolbar applyTo: self.
	^ toolbar
]

{ #category : #initialization }
CalculatorSpec1 >> initializeWidgets [
	self initializeToolbar.
	self initializeHistoryArea.
	self initializeErrorArea.
	self initializeInputArea.
	self focusOrder add: inputArea; add: historyArea.
]

{ #category : #'helper methods' }
CalculatorSpec1 >> inputArea [
	^ inputArea.
]

{ #category : #'helper methods' }
CalculatorSpec1 >> newButtonOn: aGroup hint: aHint icon: anIcon action: anAction [
	"Normally without title is good enough for related icons"
	^ self newButtonOn: aGroup title: nil hint: aHint icon: anIcon action: anAction submenu: nil.
]

{ #category : #'helper methods' }
CalculatorSpec1 >> newButtonOn: aGroup title: aTitle hint: aHint icon: anIcon action: anAction [
	"This is just to reduce the chunk of code."
	^ self newButtonOn: aGroup title: aTitle hint: aHint icon: anIcon action: anAction submenu: nil.
]

{ #category : #'helper methods' }
CalculatorSpec1 >> newButtonOn: aGroup title: aTitle hint: aHint icon: anIcon action: anAction submenu: aSubmenu [
	"This is just to reduce the chunk of code."
	^ aGroup addItem: [ :item |
			item name: aTitle.
			item description: aHint.
			anIcon ifNotNil: [ item icon: (self iconNamed: anIcon) ].
			anAction ifNotNil: [ item action: anAction ].
			aSubmenu ifNotNil: [ item subMenu: aSubmenu ].
	]
]

{ #category : #'user interaction' }
CalculatorSpec1 >> processInputExpression: textToParse [
	"User press enter on an expression"
	| newExpression message |

	"Clear old message first.."
	errorArea label: ''.

	"Clear selection to make clear is new"
	historyArea resetSelection.

	"library issue.. if the libray is under TextModel>>text:.. dont autoconfirm..."
	editloopbug ifNotNil: [ ^ self. ].

	"Parse and if all goes happy, I have the new expression, otherwise the exception shows a message"
	newExpression := [ MathExpressionParser singletonParse: textToParse ]
		on: ArithmeticError "Exception"
		do: [ :e | message := e messageText. errorArea label: message. ^ self alertMessage: message	].

	"add it in.."
	self solveExpression: newExpression.

	"Easier to start fresh"
	inputArea selectAll.
]

{ #category : #initialization }
CalculatorSpec1 >> setHistoryStart: anArrayOfExpressions [
	"Add each of the expressions from the array to the history"
	anArrayOfExpressions reverseDo: [ :each | self solveExpression: each ].
]

{ #category : #'user interaction' }
CalculatorSpec1 >> solveDerivative: anInput for: aSymbol [
	"Solves the input.."
	| solution |

	"I already checked is 'derivatible'?.. 'differentiable'?"
	solution := anInput derivativeFor: aSymbol.

	"Pass it to the generic list addition"
	self storeInput: anInput andAnswer: solution under: #derivative
]

{ #category : #'user interaction' }
CalculatorSpec1 >> solveExpression: anInput [
	"Solves the input.."
	| solution |

	"Simplify.. got something better.. keep.. otherwise try as number"
	solution := anInput simplify.
	(solution = anInput) & (solution isNumber) ifTrue: [ solution := MathExpNumber value: anInput asNumber ].

	"Pass it to the generic list addition"
	self storeInput: anInput andAnswer: solution under: #solution
]

{ #category : #'user interaction' }
CalculatorSpec1 >> storeInput: anInput andAnswer: anAnswer under: aCode [
	"Remove duplicates to clarity reasons"
	| currentList parentInfo answerInfo |

	"Notice I delete any similar with equal (not ==)"
	currentList := historyArea getList.

	"I put in a association to add extra info"
	parentInfo := self codeInSymbol: #input andExpression: anInput.

	"I dont show the solution it is the same"
	(anInput = anAnswer) & (anAnswer isNotNumber) ifTrue: [
		historyArea items: { parentInfo } , currentList.
		^ historyArea setSelectedItem: parentInfo.
	].

	"Add the answer"
	answerInfo := self codeInSymbol: aCode andExpression: anAnswer.
	historyArea items: { parentInfo . answerInfo } , currentList.

	"select the answer.. is visually clearer"
	^ historyArea setSelectedItem: answerInfo.
]

{ #category : #api }
CalculatorSpec1 >> title [
	^ 'Calculator'.
]

{ #category : #'helper methods' }
CalculatorSpec1 >> toolbar [
	^ toolbar.
]
